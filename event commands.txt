#######################
# Hearts of Iron archive (many old commands/triggers have been expanded with optional values)
#######################

Event syntax:

event = { id = [number] 	# Unike event ID number from 0 up to several billions
	random = [yes/no] 	# Is the event a random event or not. Default is set to NO. Number of random events per year is set in misc file in db folder 
	country = [tag] 	# Event can only trigger for this country. Is not mandatory
	persistent = [yes/no] 	# Can the event fire more than once. Default is set to NO
	invention = [yes/no]  	# Can only trigger once per country. Default is set to NO

	date = { hour = [0-23] day = [0-29] month = [0-11] year = [1936-1964] } 	# The earliest date this event can fire
	offset = X									# X = number of days. Means the event vil trigger once in the x days period which day is random
	deathdate = { hour = [0-23] day = [0-29] month = [0-11] year = [1936-1964] }	# The last possible date the event can trigger. Note day = 30 or higher will set deathdate at end of year.

	trigger = { [trigger conditions] } 			# possible triggers listed and explained below

	name = "[nameofevent]" or name = EVT_4000_NAME	# Name of event that will be displayed in message logs or boxes. It can either be directly written in the name field or be called from event.txt files with string names like "EVT_4000_NAME" multible events can use same name. Double quotes "" are optional if the name is not separated by whitespace.					
	Desc = "[Description]" or Desc = EVT_4000_DESC	# Description of event that will be displayed in message box. se above for explanation
	Picture = "[nameof picture]"				# Name of the event picture. Must be located in event_pics folder in gfx folder 
	style = 0						# not currently used can be omitted

	#Darkest Hour now supports infinite action amounts in an event. Previously, there could only be four
	action = { 	name = "[action name]" or name = ACTIONNAME4000A 	# name or description of action either directly wriiten or placed in event.txt file in config folder like above. 
			ai_chance = X 						# X between 0 - 100% 
			command = { [commands] } 				# Valid commands listed and explained below, number of commands in one action is unlimited for any practical purpose as far as i know
			}
	
	
	} # dont forget this at end of event.			

Trigger syntax:
	
	and = { [trigger conditions a to z] } 	# All of the conditions need to be true for the event to fire
	or = { [trigger conditions a to z] }	# Only one of the conditions need to be true for the event to fire
	not = { [trigger conditions a to z] } 	# None of the conditions, can be true for the event to fire

TRIGGERS:
	day = [0-29]			#true if the day (of the month) is at least this
	month = [name] or [0-11]	#true if the month is at least this
	year = X 			#true if the year is at least this
	
	difficulty = X 			# Difficulty at level X or harder. [0-4],0 is Very Easy.
	event = x  			# event has happened.
	random = x ( % )		# not to be confused with the above random = yes/no this sets a percentage chance for the event to trigger

	flag = [name]  			#true if the global flag exists and is set to true.
	local_flag = [name]		#true if the local flag exists and is set to true.
	
New with Darkest Hour 1.04
Expanded flag and local_flag triggers with <, <=, =, >= and > comparator options against a fixed integer value:
	flag = { which = [keyname] when = -2/-1/0/1(default)/2 value = X (default value 1) }
		# True if the global flag exists (!) and its current value is less (when = -2), 
		# less or equal (when = -1), equal (when = 0), 
		# greater or equal (when = 1 or no when used) or greater (when = 2) then value
	local_flag = { which = [keyname] when = -2/-1/0/1(default)/2 value = X (default value 1) }
		# True if the local flag exists and its current value is less (when = -2), 
		# less or equal (when = -1), equal (when = 0), 
		# greater or equal (when = 1 or no when used) or greater (when = 2) then value
	Details on current flag value and operation are displayed on the flag tool-tip when extra debug logs are set to 1 (setting.cfg).
	
	headofstate = [minister id]			# True if minister id is HOS
	headofgovernment = [minister id]		# True if minister id is HOG
	incabinet = [id] 				# True if minister id is in the ruling cabinet
	minister = [minister id] 			# True if minister are alive?
	leader = [leader id] 				# True if leader id are alive
	government = [communist/fascist/democratic]	# Checks for government type
	ideology = [name of ideology type]		# Checks for ideology of nation valid types below
	
	exists = country 				# True if country exists.
	country = [tag] 				# True if this is country
	major = [yes/no]				# True if the country is ENG, FRA, GER, JAP, USA, ITA or SOV
	ai = [yes/no/country tag] 			# Is the country AI controlled?
	atwar = [yes/no/country tag] 			# Is this country atwar yes/no or country tag added to see if other countries are at war
	war = { country =a  country = b }		# Checks if a and b is at war
	under_attack = [tag/-1]				# Country TAG or current country (-1) is under attack
	attack = [tag]					# Country [tag] has attacked this country.
	ispuppet = [Country Tag]			# True if TAG is a puppet
	puppet = { country = [tag 1] country = [tag 2] }# True if tag 1 is puppet of tag 2
	owned = { province = a data = tag }		# checks if province is owned by country x (if data == -1 then its for country receiving event)
	control = { province = a data = tag }		# checks if province is controlled by country x (if data == -1 then its for country receiving event)
	continent = "continent name"		# returns TRUE if the capital of the country in question is on that continent
	
	alliance = { country = a country = b }			# checks if a and b is in the same military alliance
	access = { country = [tag1] country = [tag2] } 		# checks if tag1 is granting military access to tag2
	non_aggression = { country = [tag1] country = [tag2] } 	# checks if tag & tag have a non_agg_pact active
	trade = { country = [tag1] country = [tag2] } 		# checks if tag1 and tag2 have an active trade agreement
	guarantee = { country = [tag1] country = [tag2] } 	# checks if tag1 is guaranteeing the independence of tag2
	domestic = { type = field value = x }			# checks if domestic slider is >= specified value se valid type fields below
	belligerence = { country = [tag] value = X }		# No country field means "this country". True if Belligerence >= X.
	can_change_policy = { type = [policy] value = [delta] } # true if the policy can be changed by delta
	relation = { which = [tag] value = [value] } 		# true if relations to country which is at least value

	lost_VP = { country = [tag] value = X }		# X% or more of _owned_ VPs in enemy hands
	lost_national = { country = [tag] value = X }	# X% or more of national provs in enemy hands
	lost_IC = { country = [tag] value = X }		# X% or more of national IC in enemy hands
	axis = X 					# axis holds at least X vp
	allies = X 					# allies holds at least X vp
	comintern = X 				# comintern holds at least X vp
	vp = X 						# Currently held Key Points + extra VP of the country this event is checked for >= X
	vp = { [country = TAG/-1] value = X } #Currently held Key Points + extra VP of TAG (or the country this event is checked for if -1 or missing) >= X	
	range = { min = x max = x }			# true if vp is within (>= && <= the range)	

	technology = x 			 		# True if a certain tech is known.
	technology = { country = TAG value = x }	# True if a certain tech is known by the given country.
	is_tech_active = [tech id]			# True if the tech is researchable.

	energy = x		(>=x)	#true if a nation have at least that amount of energy.
	metal = x		(>=x)	#true if a nation have at least that amount of metal.
	rare_materials = x	(>=x)	#true if a nation have at least that amount of rare materials.
	oil = x			(>=x)	#true if a nation have at least that amount of oil.
	supplies = x		(>=x)	#true if a nation have at least that amount of supplies.
	manpower = x 		(>=x)	#true if a nation have at least that amount of manpower.
	dissent = x  		(>=x)	#true if a nation have at least that amount of dissent.	
	money = x		(>=x)	#true if a nation have at least that amount of Money
	escortpool = x		(>=x)	#true if a nation have at least that amount of escorts
	convoypool = x		(>=x)	#true if a nation have at least that amount of convoys

	division_exists = { type = [id type] id = [id id] }				# checks for Specific division exists land/sea or air 
	division_in_province = { id = { type = [id type] id = [id id] } province = X } 	# checks for Specific division in specific province land/sea or air 
	[div type] = X									# X or more of that type of division.
	[div type] = { country = TAG value = X }					# country TAG has X or more of that type of division
	army = [divisions] 					#true if we have at least this many land divisions
	nuke = [number] 					#true if we have at least this many nukes ready
	land_percentage = { country = [tag] value = [value] }  	#true if we have at least value times the land forces of country TAG
	naval_percentage = { country = [tag] value = [value] } 	#true if we have at least value times the naval forces of country TAG
	air_percentage = { country = [tag] value = [value] }   	#true if we have at least value times the air forces of country TAG

	garrison = { [country = TAG/0/-1/-2/-3] province = [province] type = [air/land/naval] size = [number of divisions] area = [yes/no/0/1/2/3 ] } 
	# [country = TAG/0/-1/-2/-3] : 0 – all countries, current country (country = -1 or no country), enemy countries (country = -2) or allied/friendly countries (country = -3)
	# No type field means "all division types". 
	#"area = yes" means "count divisions in all provinces in this controlled Area". Do not use "area = yes" for sea provinces!	
	# area = 0/1/2/3 : 0 = (no) / 1 = area / 2 = region /3 = (yes) owner area
	intel_diff = x 								#[>=X, X = our intell - enemy intell]
	province_revoltrisk = { province = [id] value = [value] } 		# true if revolt risk in province is at least value


COMMANDS:
	type = endgame value = [type]   	# Sets conditions for when the scenario ends valid types listed below

Misc:	type = setflag which = [keyname]	# Sets Global flag, visible for all countries
	type = clrflag which = [keyname]	# Clears Global flag, visible for all countries
	type = local_setflag which = [keyname]	# Sets Local flag, visible only for this country
	type = local_clrflag which = [keyname]	# Clears Local flag, visible only for this country	

New with Darkest Hour 1.04
Expanded setflag and local_setflag commands – added optional support for setting a flag to integer value (from 0 to 32767):
	type = setflag which = [keyname] when = 0(default)/1 value = X (default value 1, 0 translates to 1 too) 
		# Sets (when = 0) or modifies (add to current flag value, when = 1) a Global flag, visible for all countries. 
		# Value can be a positive or a negative integer (!) number. Flag value (set or calculated) can be from 0 to 32767.
	type = local_setflag which = [keyname] when = 0(default)/1 value = X (default value 1, 0 translates to 1 too)	
		# Sets (when = 0) or modifies (add to current flag value, when = 1) a Local flag, visible only for this country. 
		# Value can be a positive or a negative integer (!) number. Flag value (set or calculated) can be from 0 to 32767
Policy:	type =  regime_falls						# 
	type =	inherit which = [tag] when = 0(default)/1/2/3 value = 1/0(default)		# This country inherits country Tag, [-1] for random. Value = 1 : country will receive all units and production queue too. 
		when = 0 (default) - old behavior (no player controlled country can be annexed by this command)
		when = 1 - Host could not be annexed in MP or SP games (in SP games this is effectively the same setting as when = 0)
		when = 2 - Host could not be annexed in MP games only (to avoid game stop for all other clients)
		when = 3 - Any player controlled country can be annexed
	type =	country which = [tag] 					# Change the tag of the country the event fires for.
	type =	addcore   which = [prov id]	[where = TAG/-1]	# Add new national province to TAG or current country if where = -1 or not defined
	type =	removecore which = [prov id] [where = TAG/-1]	# Remove national provinces from TAG or current country if where = -1 or not defined
	type =	secedeprovince which = [tag/-1/-2-3] value = [prov id] [when = 0(default)/1/2]	# Secede province value =[prov id] to country which=[TAG] or to current country (which = -3) or to the country that currently controls it (-1; Ignored if controlled by Rebels) or currently owns it (-2); 	
																 # when = 0(default) – use the old secede logic (has some flaws; kept for compatibility), 1 – use new secede logic (only controlled provinces change control, only owned provinces change ownership) , 2 – set owner and controller to TAG no matter who currently owns or controls the province
	type =	control which = [tag/-1]  value = [prov id]		# Set controller of province [prov id] to country [TAG] or to current country if which = -1
	type =	capital which = [prov id]		 		# Change capital for the country to [prov id]
	type = 	civil_war 				 		#DEPRECIATED, Highly recommended to use INDEPENDENCE, SWITCH_ALLEGIANCE, and WAR commands instead! # Civil war with any possible revolter that has shared national provinces
	type = 	civil_war which = [rebel country tag]	 		#DEPRECIATED, Highly recommended to use INDEPENDENCE, SWITCH_ALLEGIANCE, and WAR commands instead! # Civil war with specific revolter that has shared national provinces. NOTE: This MUST be a tag which has regular_id set to this country, or vice versa.
	type = 	belligerence which = [country] value = X 		# adds value = [x] Belligerence to country = [tag], No which field means "this country".
	type = 	dissent value = [value to add]				# adds value = [x] Dissent to country = [tag], No which field means "this country".
	type = 	province_revoltrisk which = [Province ID] value = X 	# Adds value = [x%] revoltrisk to province = [prov id; use -1 for random owned and controlled province].
		#Comments on this command:
			#Change in ownership of the province resets the revolt risk
			#Change in tag of a country resets all revolt risk
			#Revolt risk is capped by a factor related to the dissent of the country.
			#Cannot go below base revolt risk
	type = 	domestic which = [domestic policy type] value = X 	# Change a domestic policy slider by value = [X] between 1-10
	type = 	set_domestic which = [domestic policy type] value = X	# Set a domestic policy slider to value = [X] between 1-10
	type = 	change_policy which = [domestic policy type] value = X	# Change a domestic policy by value = [X] if it could normally be changed and also sets the cooldown period (found in misc file in the DB folder) for changing policy
	type = 	independence which = [country tag] value = [0/1] when = [0/1] # Country [tag] gains independence. value: [0]-units in the area change allegiance, [1]-they don't. When 0=normal, 1=force them to be democratic

Diplo :	type =	alliance which = [tag] 				# This country enters in an alliance with country = [tag], [-1] for random country.
	type = 	leave_alliance		# This country leaves alliance
	type = 	relation which = [country] value = X		# Add value = [X] to the relation with country = [tag]
	type = 	set_relation which = [country] value = X	# Sets relation to [X] with this country
	type = 	peace which = [country tag] value = [0/1] 	# Makes peace with [tag] Value = [1] means separate peace-i.e. pull out of alliance. [0] is full peace, for the whole alliance.
	type = 	war which = [country tag]			# This country Dows country = [tag], note you will get normal Belligerence for dow whit this event
	type = 	end_puppet					# End puppet status
	type = 	end_mastery which = [country tag]		# End puppet mastery over another nation
	type = 	make_puppet which = [country tag]		# Make country [TAG] a puppet to country this country
	type = 	coup_nation which = [country tag]		# This country Coups nation [TAG]
	type = 	access which = [country tag] 				# Grant military access _to_ a country
	
	type = 	end_access which = [country tag] # Revoke military access for nation
			[DH 1.04] Added a new optional parameter: when = 0 (default - end access we gave to [country tag]) / 1 ([country tag] ends access given to us)
			
	type = 	end_non_aggression which = [country] where = [country] 	# end a non aggression pact between these countries
	type = 	non_aggression which = [country] where = [country]	# create a non aggression pact between these countries
	type = 	end_trades which = [country] where = [country] 		# end all trade agreements between these countries
	type = 	end_guarantee which = [country] where = [country] 	# country 1 no longer guarantees independence of country 2
	type = 	guarantee which = [country] where = [country] 		# country 1 now guarantees independence of country 2

Teams:	
	type = sleepteam which = [tech team id]				# Makes this team unavailable (sets "start year" to 2001. Will complete current project though.)
		[DH 1.04] Added a new optional parameter: when = 0(default, old behavior)/1(do not change team start/end years but only make it dormant) 
	type = waketeam which = [tech team id]				# Makes this team available (sets "start year" to previous year.)
		[DH 1.04] Added a new optional parameter: when = 0(default, old behavior)/1(do not change team start/end years but only clear its dormant state)
	
	type = sleepminister which = [minister id/-1]			# Kills this minister, permanently unavailable
	type = sleepleader which = [leader id/-1]			# Dormant this leader (can be woken up later).
	type = wakeleader which = [leader id]				# wakes this dormant leader
	type = set_leader_skill which = [leader id/-1] value = [X] 	# Sets a leaders skill to [X], which = [-1] random leader. 

Units:	type = allow_dig_in						# Troops may now dig in
	type = build_division which = [division type] value = [brigade type] when = XXX cost = x.xx name = "unit name" where = [days for 1st]	# This command requires MP for each division it adds to the queue. So if you don't have enough MP one or more (even all) of the units could not be added to the production queue. 
		- when = XXX			# Sets serial line XXX items long.
		- cost = x.xx 			# Sets starting cost. Note that this cost will be changed automatically for players to match correct cost and for the AI if it is higher then the correct cost! If set to negative (-0.2) , then the cost will be fixed for players too (set to 0.2) and for AI countries this unit will be inserted on top of the build queue instead of being appended at the bottom.
		- name = "unit name"	# Sets unit name. Note that it cannot be more then 256 characters in size!
		- where = XXX			# Sets days till completion of the first item. Note that it cannot be bigger then default completion time of 1 item!
	type = add_corps which = [name] value = [land/air/naval] when = [leader ID] where = [province_ID]
	type = activate_division which = [div id type] value = [div id id]  [where = province] when = [0/1] # Activates a dormant division. If "when = 0" the division will deploy to the force pool if the target province is enemy controlled. If a preceding add_corps command has been used, the division will go to that unit, ignoring the 'when' and 'where' directives.
	type = add_division which = [name] value = [div type] when = model where = [brigade type / negative number] # Brigade model is always the latest. If a preceding add_corps command has been used, the division will go to that unit, otherwise to the force pool. If when is negative number, then a damaged unit will be created (when = -80 will create a division with STR = 20)
	type = remove_division which = [div id type/-1] value = [div id id]			# Remove a division from the scenario. -1 is a random division (the value field will be ignored).
	type = remove_division which = "Exact Name" value = [country tag]			# Remove a named division from the scenario (for a certain country.)
	type = damage_division which = [div id type/-1] value = [div id id] where = X		# where = Percent of Max Strength. Negative value is strength gain. Division could end with strength between 0 and Max Strength. 
	type = damage_division which = "Exact Name" value = [country tag] where = X			# Damage a named division for a certain country. where = Percent of Max Strength. Negative value is strength gain. Division could end with strength between 0 and Max Strength. 
	type = disorg_division which = [div id type/-1] value = [div id id] where = X		# where = Percent of Max Strength. Negative value is org gain.
	type = delete_unit which = [unit id type/-1/-2/-3] value = [unit id id] 		# -1 is a random land unit -2 random naval unit -3 random air unit (value will be ignored).
	type = switch_allegiance which = [unit id type/-1] value = [unit id id]	where = [country tag]	# -1 is a random land unit -2 random naval unit -3 random air unit (value will be ignored).
	type = scrap_model which = [div type] value = [model]					# Make a model obsolete (no longer possible to build).
	type = lock_division which = [id type] value = [id id] 					# Lock this division (it may no longer move.)
	type = unlock_division which = [id type] value = [id id] 				# Unlock this division (it may now move.)
	type = new_model which = [division or brigade type] value = [The model number] } 	# New models updates the current template for a division or brigade type.
	type = activate_unit_type which = [division or brigade type] } 				# Make a division or brigade type available for construction.
	type = deactivate_unit_type which = [division or brigade type] } 			# Make a division or brigade type unavailable for construction.
	type = carrier_level value = XXX.XX	#country-independent bonus to every carrier into a naval combat (Bonus = (OurCarrierLevel - TheirCarrierLevel) / 10 ). Specified value replaces currently used (it is not additive command). By default this value for all countries is 0.0 (and so the bonus is 0%). 
	
Techs:	type = research_sabotaged			# Research is set back with X%.
	type = deactivate which = [tech id] 		# Make this technology permanently unavailable for the country.
	type = activate which = [tech id] 		# Activate specific techs
	type = info_may_cause which = [tech id]		# No effect, but informs player that this tech/event can open up new avenues of research.
	type = steal_tech which = [country tag/-1] 	# Steals a random tech. from country = [tag] or  [-1] for random non-ally, Results in a blueprint.
	type = gain_tech which = [tech id/-1/-2]	# Gains a blueprint, [-1] for random tech, [-2] for a random tech currently being researched not a technology.

R.Pool: type = resource which =[resource type] value = X 	# % of theoretical maximum daily production added to national resource pool.
	type = supplies value = [value to add] where = [prov] 	# If no "where" field is used, it goes to the national pool.
	type = oilpool value = [value to add] where = [prov] 	
	type = metalpool value = [value to add] where = [prov]
	type = energypool value = [value to add] where = [prov]
	type = rarematerialspool value = [value to add] where = [prov]
	type = money value = [value to add] where = [prov]
	type = manpowerpool value = [value to add]
	type = relative_manpower value = [%] 			# Add a percentage of [yearly national manpower income * 50] to the pool
	type = province_manpower which = [prov] value = [value to add] # Add manpower to province. Use which = -1 for random owned province	
	type = free_ic/free_oil/free_supplies/free_money/free_metal/free_energy/free_rare_materials/free_transport/free_convoy/free_manpower	#change offmap daily prod
	type = add_prov_resource which = [prov id/-1/-4] value = X where = [energy/metal/oil/rare_materials]  # -1 is random owned province, -4 is province with nuclear reactor.

Constr:	type = allow_building which = [building type]	# Allow the construction of a certain building type.
	type = construct which = [building type] where = [prov id/-1/-4] value = [additional size] # -1 is random valid province. -4 is random national province that already has a building of the same type of at least size 1.
	type = allow_convoy_escorts			# Allowed to build convoy escorts
	type = transport_pool which = [country tag/-1] value = X (adds/removes transports from pool) #-1 is current country
	type = escort_pool which = [country tag/-1] value = X (adds/removes escorts from pool) ##-1 is current country
	type = convoy which = [startprov] value = [endprov] when = [resource_bits] 1=oil, 2=metal, 4=energy, 8=rare_materials, 16=supplies
	
Mod:	type = peacetime_ic_mod value = X(%) 	# Additive, and ONLY applied when a country is at peace. Default base value is 100%.
	type = tc_mod value = X(%)		# Modify National Transport Capacity. Positive value = good.
	type = tc_occupied_mod value = X(%)	# Modify Occupied Province Transport Capacity Drain. Positive value = good.
	type = attrition_mod value = X(%)	# Modify the Attrition Penalty. Positive value = good.
	type = supply_dist_mod value = X(%)	# Modify the Supply Distance Penalty. Positive value = good.
	type = repair_mod value = X(%)		# Modify Reinforcement Efficiency Positive value = good.
	type = research_mod value = X(%)	# Modify research efficiency. Positive value = good.
	type = building_prod_mod which = [building type] value = X%	# Bonus to production time. Additive. NOTE: Positive value = reduced time.
	type = convoy_prod_mod which = [escorts/transports] value = X%	# Bonus to production time. Additive. NOTE: Positive value = reduced time.
	type = radar_eff value = X(%) 		# Modify the efficiency of radar stations (bonus to friendly aircraft in the province.) Positive value = good.

Eff: 	type = enable_task which = [task type]			# Enable a certain type of mission
	type = task_efficiency which = [task type] value = X 	#Additive: 0.05 - 1.0
	type = max_positioning which = [div type] value = X 	#Additive: 0.05 - 1.0
	type = min_positioning which = [div type] value = X 	#Additive: 0.05 - 1.0

Misc:	type = province_keypoints which = [province id/-1] value = [keypoints to add]
	type = ai which = [file name]	# Switches the ai file of a country.
	type = extra_tc value = X
	type = vp value = X 		# Offmap Victory Points
	type = songs which = X #should read the song(s) listed in file “X” and then go back to the playlist previously playing
	type = trigger which = [event id]	# Immediately trigger another event
	type = sleepevent which = [event id]

Nuclear:type = max_reactor_size value = X # Set the max size of nuclear reactor buildings.
	type = abomb_production 	  # Allow A-Bombs
	type = double_nuke_prod		  # Double A-Bomb production rate.

	type = gas_attack            	# Enable gas attacks 
	type = gas_protection        	# Enable gas protection

# AI event commands (no effect for human controlled nations)
	type = ai_prepare_war	which = [tag]		# Tells the AI to move troops to the border with a country.

# Weather event commands
	type = start_pattern which = [id type] value = [id id] where = [prov id] when = [raining/snowing/storm/blizzard]	# Start a new weather pattern centered on a given province
	type = add_to_pattern which = [id type] value = [id id] where = [prov id] when = [raining/snowing/storm/blizzard]	# Add a province to an existing weather pattern.	
	type = end_pattern which = [id type] value = [id id] # This weather pattern will begin to dissipate
	type = set_ground which = [prov id] value = [clear/muddy/winter]

# Commands to affect the chance of "combat events" occurring. Additive (%).
	type = counterattack value = x
	type = assault value = x
	type = encirclement value = x
	type = ambush value = x
	type = delay value = x
	type = tactical_withdrawal value = x
	type = breakthrough value = x

# HQ effects
	type = hq_supply_eff value = X(%)	# Additive
	type = sce_frequency value = X	 	# Combat event chance multiplier. Default: 1.0	

# ACTIVATE NUCLEAR CAPABILITY OF MISSILES
 	type = nuclear_carrier which = [flying_bomb/flying_rocket] }

# ACTIVATE MISSILE CAPABILITY OF SUBMARINES
 	type = missile_carrier which = [submarine] }

# UNIT VALUES
# [unit value] = out_of_fuel_speed/no_fuel_combat_mod/no_supplies_combat_mod/soft_attack/hard_attack/defensiveness/toughness/softness/morale/suppression/air_attack/air_defense/build_cost/build_time/manpower/speed/max_organization/transport_weight/supply_consumption/fuel_consumption/speed_cap_art/speed_cap_eng/speed_cap_at/speed_cap_aa
#
# Land unit bonuses
	type = [unit value] which = [land/division type/brigade type] value = [additive value modifier] }

# Air unit bonuses
	type = [no_fuel_combat_mod/no_supplies_combat_mod/air_attack/strategic_attack/tactical_attack/naval_attack/air_defense/build_cost/build_time/manpower/speed/surface_detection/air detection/transport_capacity/supply_consumption/fuel_consumption/range] which = [air/division type/brigade type] value = [additive value modifier] }

# Naval unit bonuses
	type = [no_fuel_combat_mod/no_supplies_combat_mod/naval_attack/air_attack/shore_attack/naval_defense/air_defense/build_cost/build_time/manpower/speed/surface_detection/air detection/visibility/transport_capacity/supply_consumption/fuel_consumption/range] which = [naval/division type/brigade type] value = [additive value modifier]
}
# NOTE: For "build_time" and "build_cost", it is possible to add the field "where = relative".
# This means that the value is parsed as a relative modifier (%) instead of an absolute addition.
# When doing this, THE BASE VALUE OF MODEL 0 IS USED FOR _ALL_ MODELS. So "value = -10" means
# "-10% of the value of model 0".
# NOTE 2: For "build_time", "build_cost" and "manpower" it is recommended to use "when = on_upgrade" for perfomance reasons. (these 3 modifiers are not applied directly to the existing units)
# For all other modifiers it is recomended to use "when = now" (or skip the "when" setting) to apply those immediately to all currently deployed and future units.

#
# UNIT COMBAT MODIFIERS
#
# Terrain combat modifiers
	type = [plain_attack/plain_defense/desert_attack/desert_defense/mountain_attack/mountain_defense/hill_attack/hill_defense/forest_attack/forest_defense/swamp_attack/swamp_defense/jungle_attack/jungle_defense/urban_attack/urban_defense/river_attack/shore_attack] which = [division type/brigade type] value = [X] } # Modifier in percent (+10 = 10%)

# Terrain movement modifiers
 	type = [plain_move/desert_move/mountain_move/hill_move/forest_move/swamp_move/urban_move/jungle_move] which = [division type/brigade type] value = [X] } # Modifier in percent (+10 = 10%)

# Weather combat modifiers
	type = [clear_attack/clear_defense/frozen_attack/frozen_defense/snow_attack/snow_defense/blizzard_attack/blizzard_defense/rain_attack/rain_defense/storm_attack/storm_defense/muddy_attack/muddy_defense] which = [division type/brigade type] value = [X] } # Modifier in percent (+10 = 10%)

# Night modifiers
	type = night_move/night_attack/night_defense which = [division type/brigade type] value = [X] } # Modifier in percent (+10 = 10%)
#
# SPECIAL UNIT BONUSES
#
# Minisubs (BBs and CVs attack ships in harbors with this bonus added to their sea attack value)
	type = minisub_bonus value = [X] }# NOT INCREMENTAL. This is the new value.
#
# GLOBAL MODIFIERS
#
# Surprise modifiers
	type = surprise which = [naval/land/air] value = [X] } # Modifier in percents

# Intelligence Operation modifiers
	type = intelligence which = [us/them] value = [X] } # Modifier in percents

# Army Detection modifiers
	type = army_detection which = [us/them] value = [X] } # Modifier in percents

# Provincial AA batteries
	type = AA_batteries value = [X] } # Modifier in percents
#
# INDUSTRIAL MODIFIERS
#
# Industrial multipliers
# E.g. energy_to_oil 4 means four energy are needed to produce one oil. 0.5 means 1 energy produces 2 oil.
	type = industrial_multiplier which = [energy_to_oil/oil_to_rare_materials] value = [X] }

# Industrial modifiers (additive)
# 'total' is the conversion factor from every built industry point into Industrial Capacity.
# 'supplies' is a modifier for the amount of supplies produced by every reserved IC unit.
	type = industrial_modifier which = [total/supplies] value = [X] } # Percents
#Government types:
#[Democratic/Fascist/communist]

#Ideology types:
#[nazi/fascist/paternal_autocrat/social_conservative/market_liberal/social_liberal/social_democrat/left_wing_radical/leninist/stalinist]

#Domestic policy types:
#[democratic/political_left/free_market/freedom/professional_army/defense_lobby/interventionism]

#Building Types:
#[ic, coastal_fort, land_fort, flak, infrastructure, air_base, naval_base, radar_station, nuclear_reactor, rocket_test]

#Task Types:
#[attack, rebase, strat_redeploy, support_attack, support_defense, reserves, anti_partisan_duty, planned_defense, air_superiority, ground_attack, runway_cratering, installation_strike, interdiction, naval_strike, port_strike, logistical_strike, strategic_bombardment, air_supply, airborne_assault, air_scramble, convoy_raiding, asw, naval_interdiction, shore_bombardment, amphibous_assault, sea_transport, naval_combat_patrol, sneak_move, naval_scramble]

#Resource Types: 
#[oil, metal, energy, rare_materials, supplies, money, manpower]

#Division types
#[infantry/,.......]

#Endgame types
#[0=quit, 1=eliminated, 2=draw, 3=axis victory, 4=axis total vic, 5=allies-victory, 6=alliestotal, 7=commie, 8=commietotal]


##########################
# New with Darkest Hour :
##########################

# Event Header

tag = { TAG1 TAG2 TAG3 … TAGX }

Added new option to generic events decision used to define countries which this event/decision is available for. No country = TAG should be specified for such events/decisions. The event/decision will be available only for the specified countries. This will greatly improve game speed when a lot of generic events are used for just few countries (set in event’s triggers). 

save_date = yes / no (default); If set saves date when this event has fired and that date can be used as a trigger by other events (delay event B to fire at least X days after event A). NOTE!!! Valid event IDs range is 0 to 2,147,483,647!!!

one_action = yes / no (default); If set show just one (random) action to the player. The action is chosen based on AI chances (if present), else it is random using the same rules as for the AI (set in misc.txt).

style = 0/1/2 # 0 = uses vanilla event screens 1 = allow bigger pictures to be used 2 = uses the new newspaper style event screens

all = [yes/no] #When such event is triggered by another event, it will be executed for all countries in the TAG = { … } list or for all countries in the world if no TAG (and no country) is specified. Default is set to NO


# Triggers :
NOTE: Parameters into [ ] are optional and can be skipped.

government = { type = GOV_TYPE [country = TAG] }	# check if government type of TAG or current country when no country is defined (or = -1) is equal to GOV_TYPE
ideology = { type = IDEOLOGY_TYPE [country = TAG] }	# check if ideology type of TAG or current country when no country is defined (or = -1) is equal to IDEOLOGY_TYPE

military_control = { country = TAG1 country = TAG2 }# check if TAG2 has military control over TAG1
military_control = { country = TAG [country = -1] }	# check if country in question has military control over TAG
military_control = { country = -1 country = TAG }	# check if TAG has military control over country in question

non_aggression = { country = TAG [country = -1] }	# check if the country in question has NA pact with TAG
non_aggression = { country = -1 country = TAG }		# check if TAG has NA pact with the country in question

alliance = { country = TAG [country = -1] }         # chect if TAG is allied to the country in question
alliance = { country = -1 country = TAG }			# check if the country in question is allied to TAG

war = { country = TAG [country = -1] }				# check if TAG is at war with the country in question
war = { country = -1 country = TAG }				# check if the country in question is at war with TAG

access = { country = TAG [country = -1] }			# check if the country in question has access to TAG
access = { country = -1 country = TAG }				# check if TAG has access to the country in question

guarantee = { country = TAG [country = -1] }		# check if TAG guarantees independence of the country in question
guarantee = { country = -1 country = TAG }			# check if the country in question guarantees independence of TAG

trade = { country = TAG [country = -1] }			# check if the country in question has a trade deal with TAG
trade = { country = -1 country = TAG }				# check if the country in question has a trade deal with TAG

puppet = { country = TAG [country = -1] }			# check if the country in question has country TAG as puppet
puppet = { country = -1 country = TAG }				# check if country in question is puppet of TAG

navy = { size = X [type  = 0/1] [when = 0/1] [where = 0/1] [which = 0/1] [country = TAG] }
							# check if TAG (or country in question when not specified or country = -1) has at least X ships 
							# type  = 0 (default) - count all ship types, type  = 1 - count all except TP, SS and SSN
							# when = 0 (default) - count only ready ships, when = 1 - count ready + ships under construction
							# where = 0 (default) - count foreign expeditionary forces too, where = 1 count own forces under own control only
							# which = 0 (default) - slow, but accurate real-time check, which = 1 (recommended) fast check that uses daily updated stats only for own units, including sent as expeditionary forces to other countries
navy = X					# check if country in question has at least X ships of all types ready, including foreign expeditionary forces and excluding own units sent to other countries

air = { size = X [type  = 0/1] [when = 0/1] [where = 0/1]  [country = TAG] }
							# check if TAG (or country in question when not specified or country = -1) has at least X airplanes 
							# type  = 0 (default) - count all airplanes types, type  = 1 - count all except TRA, Rockets and Flying bombs
							# when = 0 (default) - count only ready airplanes, when = 1 - count ready + airplanes under construction
							# where = 0 (default) - count foreign expeditionary forces too, where = 1 count own forces under own control only
							# which = 0 (default) - slow, but accurate real-time check, which = 1 (recommended) fast check that uses daily updated stats only for own units, including sent as expeditionary forces to other countries
air = X						# check if country in question has at least X airplanes of all types ready, including foreign expeditionary forces and excluding own units sent to other countries															

army = { size = X [type = 0/1] [when = 0/1] [where = 0/1] [which = 0/1] [country = TAG] }	
							# check if TAG (or country in question when not specified or country = -1) has at least X land divisions 
							# type = 0 (default) - count all land unit types, type = 1 - count all except GAR and HQ
							# when = 0 (default) - count only ready divisions, when = 1 - count ready + divisions under construction
							# where = 0 (default) - count foreign expeditionary forces too, where = 1 count own forces under own control only
							# which = 0 (default) - slow, but accurate real-time check, which = 1 (recommended) fast check that uses daily updated stats only for own units, including sent as expeditionary forces to other countries
army = X					# check if country in question has at least X land divisions of all types ready, including foreign expeditionary forces and excluding own units sent to other countries

research_mod = { value = X [country = TAG] }	# check if research modifier for TAG (or country in question if not specified or country = -1) is at least X
research_mod = X	# check if research modifier for country in question is at least X
	
*ispuppet = [TAG/yes]			# True if TAG is a puppet. Use ispuppet = yes to check if the country in question is puppet to another country.

escortpool = X               # changed to check for total escorts instead just for unassigned

convoypool = X               # changed to check for total convoy transports instead just for unassigned

lost_VP = { value = X }            # X% or more of _owned_ VPs of the country in question are in enemy hands

lost_national = { value = X }         # X% or more of national provs of the country in question are in enemy hands

lost_IC = { value = X }            # X% or more of national IC of the country in question is in enemy hands

participant = { [country = TAG] value = 1/2/3/4 }    # check if TAG (or country in question if not specified) is part of Allies (1), Axis (2), Comintern (3) or any alliance (4)

capital = { province = a [data = tag] }      # check if that province is the capital of TAG (or country in question if not specified)

core = { province = a [data = tag ] }      # check if that province is core for TAG (or country in question if not specified)

policy = { [country = TAG] type = [policy] value = X }    # true if the policy of TAG (or country in question if not specified) is equal or greater then X. Value is 1 to 10

[div type] = { [country = TAG] value = X [when = now] }   # check if TAG (or country in question if not specified) has X or more of that type of division. when = now counts only already built divisions.

building = { province = ID type = building_type value = X [when = now] }   # check if in the specified province that building_type is at least at level X; when = now for current size, else - max size

ic = X / ic = { [country = TAG] value = X [when = now] }   # check if TAG (or country in question if not specified) has X or more Total IC ([when = now] ) or Base IC; ic = X checks if current country has at least X total IC

nuclear_reactor =  X / nuclear_reactor = { [country = TAG] value = X [when = now] }   # check if TAG (or country in question if not specified) has nuclear reactor at X or more current size ([when = now] ) or max size; nuclear_reactor = X checks if current country has at least nuclear reactor with X current size

rocket_test =  X / rocket_test = { [country = TAG] value = X [when = now] }   # check if TAG (or country in question if not specified) has rocket test sites at X or more current size ([when = now] ) or max size; rocket_test = X checks if current country has at least rocket test site with X current size

- embargo = { country = [tag1/-1] country = [tag2/-1] [value = 0/1/2]}    # checks if tag1 (or current country if -1) has trade (value = 1), tech (value = 2) or any (value = 0 or no value) embargo to tag2 (or current country if -1 or not defined)

owned = { province = a [data = tag] }   # checks if province is owned by country x. If data = -1 or no data then it’s for country receiving event; -2 is Enemy; -3 is allied (war or diplomatic alliance) or event receiver

control = { province = a [data = tag] }   # checks if province is controlled by country x. If data = -1 or no data then it’s for country receiving event; -2 is Enemy; -3 is allied (war or diplomatic alliance) or event receiver

tech_team = ID / tech_team = { id = X [country = TAG] }   # checks if team with id X is active (current year is in between team’s start/end year) in the current country (no country entry), in a specified country (TAG) or in any country (country = -1, or just team = ID)

area = { area = name [country = TAG/-1/-2/-3] [data = 1/2] [value = X] } # check if all provinces (value = 100 or no value) or percentage (value = X, 0..100%, cannot be less then 1 province) in the area are controlled (data = 1 or no data) or owned (data = 2) by the current country (country = -1 or no country), enemy countries (country = -2) or allied/friendly countries (country = -3)

region = { region = name [country = TAG/-1/-2/-3] [data = 1/2] [value = X] } # check if all provinces (value = 100 or no value) or percentage (value = X, 0..100%, cannot be less then 1 province) in the region are controlled (data = 1 or no data) or owned (data = 2) by the current country (country = -1 or no country), enemy countries (country = -2) or allied/friendly (country = -3)

nuked = X / nuked = { country = TAG1 [country = TAG2] data = X [where = Y] }
       - nuked = -1    # True if against that country have been used more the 1 nukes
       - nuked = 1   # True if that country has used at least one nuke against any country
       - nuked = { country = FRA  country = GER data = 1 where = 300 }   # True if France(FRA) has used at least 1 nuke to Germany (GER) in Berlin (ID #300)
       - nuked = { country = FRA  data = -1 }   # True if against France(FRA) has been used at least 1 nuke by any country
       - nuked = { country = GER data = -2 where = 300 }   # True is against Germany have been used at least 2 nukes (by any country) at Berlin

intelligence = X / intelligence = { [country = TAG] value = X [data = 1/2/3] }   # True if intel level is at least X in the current country (intelligence = X, or no TAG) or country in question (TAG); data: 1 (default) intell level, 2 – foreign intelligence, 3 – counter espionage

intel_diff = { country = TAG1 [country = TAG2] value = X [data = 1/2/3] }   # True if TAG1 intel efficiency in TAG2 – TAG2 intel efficiency in TAG1 is at least X (data = 1 or no data), TAG1 intel level – TAG 2 intel level is at least X (data = 2), or TAG1 intell efficiency in TAG 2 is at least X. If no TAG2 check for current country in TAG1. value could be negative.

stockpile = oil/energy/metal /rare_materials/supplies/money   # Returns true if Stockpile is set for the given resource.

import = oil/energy/metal /rare_materials/supplies/money   # Returns true if Import is enabled for the given resource.

export = oil/energy/metal /rare_materials/supplies/money   # Returns true if Export is enabled for the given resource.

resource_shortage = oil/energy/metal /rare_materials/supplies/money/all   # Returns true if there is resource shortage for that resource or for any resource when used with “all”. NOTE: This trigger is not very reliable because it is set correctly on the second game day on every game session.

event = { id = EVENT_ID days = X  }   # Check if event with EVENT_ID has fired at least X days ago

claims = { province = a [data = tag ] } # checks if that province is claimed by TAG (or country in question if not specified) 

losses = { [country = TAG/-1(default)] [type = equipment_type(default is manpower)] value = X [data = 0(default)/1/2] }
	# Checks if TAG (or country in question if not specified or country = -1) took at least X losses of equipment_type (data = 0 or no data),
	# inflicted at least X losses of equipment_type (data = 1) or if (inflicted - taken) losses of equipment_type are at least X (data = 2)
losses = X	#Check if current country lost at least X manpower 

alliance_leader = { [country = TAG/-1(default)] value = 0(default)/1/2/3/4 } 
	# Checks if TAG (or country in question if not specified or country = -1) is leader of any alliance (0; returns false if not member of any alliance too), Allies (1), Axis (2), Comintern (3) or a minor (4) alliance 
alliance_leader = 0/1/2/3/4	# Check if current country is leader of an alliance

	
# Commands

type = add_leader_skill which = [leader id/-1] value = [X] #  increase leader skill

*type = leave_alliance [when = 0/1]		# This country leaves alliance
	when = 0 (default, pre DH 1.03 behavior) - Do not leave old wars when leaving the alliance. 
		Note: This setting can create unwanted in-game situations and using it should be avoided!
	when = 1 – Leaves old alliance wars (white separate peace) together with leaving the old alliance.
		
*type =	alliance which = [tag/-1] [where = 1/2/3] [when = 0/1/2] # This country enters in an alliance with country = [tag], [-1] for random country, 
		where = 1 – Axis/ 2 – Allies / 3 – Comintern, 
		when = 0 (default, pre DH 1.03 behavior) -  Leave old alliance before joining the new one. 
			Notes: 	
				Only puppets will follow into the new alliance. 
				This setting can create unwanted in-game situations and using it should be avoided!
		when = 1 - Bring old allies into the new alliance and merge all wars. Recommended setting
		when = 2 - Leave old alliance before joining the new one. 
			Notes: 
				Only puppets will follow into the new alliance. 
				Leaves old alliance wars (white separate peace) together with leaving the old alliance!
		General notes on how alliances are merged or created:
			1. Both countries are not allied to anyone. 
				A new aliance is created, both countires are added to it (the country that triggers the event is made alliance leader), all wars are merged.
			2. One of the countries is already allied with another country. 
				The non-allied country joins the existing alliance, keeping the old alliance leader. All wars are merged
			3. Both countries have own alliances.
				The alliance of the country that triggers the event is used UNLESS the other country is leader of the Axis or of the Allies. In that case the country that triggers the event joins the Axis/Allies respectively, leaving its old alliance.
				The [when = 0/1/2] setting is taken into account and is applied to the country that leaves its alliance no matter if it was the one that triggered the event or the other.
			4. The country joins an empty major alliance [where = 1/2/3].
				The country is made leader of the said alliance, all old allies follow, old alliance wars are kept unchanged.
			5. The country joins a non-empty major alliance [where = 1/2/3].
				If the country is not allied to anyone it will join the major alliance, all wars will be merged.
				If the country is already member of another alliance, then it will leave the old alliance first, taking into account the [when = 0/1/2] setting.
			The [when = 0/1/2] setting is ignored in all cases except #3 and #5  

type = alliance_leader [which = TAG] [where = 0(default)/1/2/3] # Sets TAG (or country in question if no which is specified) as the new leader of Axis (where = 1), Allies (where = 2) or Comintern (where = 3) or of its current alliance

type = alliance_name which = “XXXXX” where = 1/2/3 # Sets Axis (where = 1), Allies (where = 2) or Comintern (where = 3) name to defined as ALLIANCE_XXXXX in a CSV file, victory string - GAME_END_XXXXX_VICTORY, total victory string - GAME_END_XXXXX_TOTAL, alliance picture used on game quit/scenario end - gfx\interface\XXXXX_ledg.bmp and background picture used on alliance victory - gfx\interface\frontend\endgame_XXXXX.bmp

type = build_division which = [division type] value = [brigade type] when = XXX        # when for serials

type = stockpile which = (industry / supplies (used for oil too) / all) when = ( war / peace / all ) value = XX

type = auto_trade which = (oil/energy/metal /rare_materials/supplies/money) when = (import/export/stockpile) value = 1/0 # toggle auto-trade options

type = auto_trade_reset # reset auto-trade options to defaults (Stockpile disabled, Import and Export enabled for all resources)

type = military_control which = TAG where = TAG value = 1/0 # which – controlling country; where – controlled country; value – 1(assume MC), 0 (relinquish MC)

type = flag_ext where = TAG/-1 [which = "string"] # where – change flag of TAG or current country if where = -1; which  - add that string to flag/shield/counter name and skin folder; use empty string ("") or no [which] to clear.

type = country which = TAG # changes current country to TAG

type = embargo which = TAG/-1 where = TAG/-1 [value = -2/-1/0/1/2/3] # which – enforcer; where – subject; 
		# value: -2 – clear tech embargo; -1 – clear trade embargo; 0 or no value – clear all embargoes; 
		#		1 – enforce trade embargo; 2 – enforce tech embargo; 3 – enforce both trade and tech embargoes; 
		# which = -1 : use current country as enforcer; 
		# where = -1 : use current country as subject; 
		# If which = where : value =  0 (clear all embargoes the country has), 
		#							 -1 (clears all trade embargoes the country has), 
		#							 -2 (clears all tech embargoes the country has)

type = name where = TAG/-1 [which = “string”] # where – change name of TAG or of current country if where = -1; which  - new country name; use empty string (“”) or no which to reset name to default. “name” now can be a string in any of the CSV text files.

type = secedearea which = TAG/-1/-2/-3 value = AREA_NAME [when = 0(default)/1/2]	# Secede provinces in AREA_NAME to country which=[TAG] or to current country (which = -3) or to the country that currently controls it (-1; Ignored if controlled by Rebels) or currently owns it (-2); 	
														# when = 0(default) – use the old secede logic (has some flaws; kept for compatibility), 1 – use new secede logic (only controlled provinces change control, only owned provinces change ownership) , 2 – set owner and controller to TAG no matter who currently owns or controls the province

type = secederegion which = TAG/-1/-2/-3 value = REGION_NAME [when = 0(default)/1/2]	# Secede provinces REGION_NAME to country which=[TAG] or to current country (which = -3) or to the country that currently controls it (-1; Ignored if controlled by Rebels) or currently owns it (-2); 	
														# when = 0(default) – use the old secede logic (has some flaws; kept for compatibility), 1 – use new secede logic (only controlled provinces change control, only owned provinces change ownership) , 2 – set owner and controller to TAG no matter who currently owns or controls the province

type =	inherit which = [tag] value = 1/0(default)		# This country inherits country Tag, [-1] for random. Value = 1 : country will receive all units and production queue too

type =  trade which = TAG where = TAG  [energy = x]  [metal = x]  [rare_materials = x]  [oil = x]  [supplies = x]  [money = x] [when = Days duration / default is 100 years] [value = 1/0 – default, can be broken, 1 = not]
	
type = wartime_ic_mod value = X(%) 	# Additive, and ONLY applied when a country is at war. Default base value is 100%.

type = addclaim which = [prov id] [where = TAG/-1] # Set province [prov id] as claimed by TAG or current country if where = -1 or not defined

type = removeclaim which = [prov id] [where = TAG/-1] # Remove province [prov id] from claimed provinces list for TAG or current country if where = -1 or not defined

type = manpowerpool value = [value to add] [when = 1/0] # When set 1 add the MP as percentage (value = x.x) of the MP in all controlled national provinces.

type = land_fort_eff value = [X.X] # Value is added to the current value 1.0 = 100%

type = coast_fort_eff value = [X.X] # Value is added to the current value 1.0 = 100%

type = convoy_def_eff value = [X.X] # Value is added to the current value 1.0 = 100%

type = ground_def_eff value = [X.X] when = [0/1/2] # when = 0 (or no when) - Value replaces the current value 1.0 = 100%, when = 1 - Value added to current GDE, when = 2 - reset GDE to global default (set in misc.txt)

type = strength which = [all/land/air/naval/unit type] when = [0/1] where = [0/1] [org = x.xx] value = [+/- x.xx] 
	#which 	- specifies unit type(s)
	#when	- 0 – set STR value (if value = 0.0 then the this unit will be instantly deleted), 1 – add to STR value (final STR cannot be less then 0.01 or 1% and more then max unit STR, usually 1.0 or 100%)
	#where	- 0 – take/return MP from/to the pool. If there is not enough MP then the command is skipped. 1 – Ignore MP pool (MP not taken/added to it).
	#value	- 0.0 (0%) to 1.0 (100%). Can be negative if when = 1
	#org	- Percentage of the current ORG that should remain if when = 0 (0.0 – set ORG to 0%, 1.0 – keep current ORG unchanged. Default is 1.0. NOTE: This value is modified by the actual STR change for each division). Set ORG to percentage of max. Org if when = 1  

type = event which = [event id] where = TAG/-1(current country) when = [delay](in days) 
	# Trigger [event id] for country TAG or for the current country [delay] days later. 
	# If there is no delay set or it is 0 (when = 0), then the event is instantly executed.
	# Limitations: 
	#	Queued events should use the same format as events that are called directly form another event (no date and offset, no trigger etc.)
	#	If the country does not exists or ceases to exist before the execution of the event, then this event might not trigger at all
	# Save-game format (in globaldata { … }): queued_events = { event = { tag = TAG  id = EVENT_ID hour = Remaining hours until triggering } … }

type = wakeminister which = [minister id / -1] # makes a dormant minister available. Use -1 to activate a random dormant minister.

type = demobilize which = [unit_type/land/air/naval] when = [1/0] where = [1/0] value = [+/- X] # Deletes X or set to no more then X units of the specified type for a country
	#which – unit type or land, naval, air branches that will be reduced in number
	#when – 0(default) - scrap most obsolete or damaged units first, 1 – scrap best units first
	#where – 0(default) - return MP from disbanded units to the MP pool, 1 – do not return MP from disbanded units to the MP pool
	#value – >= 0 - How many units of the specified type to remain, < 0 – how many units of the specified type to be disbanded

type = strength_cap which = [unit_type/land/air/naval] when = [1/0] where = [1/0] value = [+/- X]
    which - unit type or land, naval, air to set max strength to
    when - 0(default) - set max strength, 1 - add to max strength
    where - 0(default) - apply to new units too, 1 - apply only for currently deployed units
    value - strength to set max strength to (should be >= 1.0) or to add (can be negative too; note that the final strength cannot be less then 1 %)	

type = revolt which = [Prov_ID/-1/-2/-3] [when = 0/1]	# creates a partisan division in province with ID = Prov_ID or in a random province (which = -1/-2/-3).
			# [which = -1] - selects a random owned and controlled non-national province; "when" setting is ignored
			# [which = -2] - selects a random owned and controlled province; "when" setting is ignored
			# [which = -3] - selects a random controlled province; "when" setting is ignored
			# [when = 0] (default) - province must be owned by the country; when = 1 - ignore current owner and controller of the province

type = remove_units which = [all/land/air/naval/division_type] [where = TAG/-1/-2] [when = 0/1/2/3] value = [prov_ID/Area Name/Region Name/Continent Name] 
# Remove units of a country from province, area, region or continent. 
# Command applies to deployed units, units redeploying to or loaded on planes/ships at the target area. 
# Units loaded on removed transport vessels will be redeployed to the capital.
	which = all (Default) / land / air / naval / division_type					# Type or class of units to be removed
	where = TAG / -1 (current country – Default) / -2 (apply to all countries)	# Apply to units of the specified country
	when = 0 (Province - Default) / 1 (Area) / 2 (Region) / 3 (Continent)		# Zone type to apply the command to
	value = prov_ID (when = 0 or no “when” used) / Area Name (when = 1) / Region Name (when = 2) / Continent Name (when = 3)	# Where to apply the command 
			
# Policy Sliders

All policy modifiers are now moddable from policy_effects.csv

new policy modifier:
_MODIFIER_RESEARCH_SPEED_
_MODIFIER_INTEL_COST_
_MODIFIER_INTEL_MAINTENANCE_
_MODIFIER_RESOURCE_PROD_
_MODIFIER_STOCKPILES_
_MODIFIER_USE_BELLIGERENCE_FOR_DOW_ # Additive. Use belligerence in “is DoW allowed” calculation – replacing old hard-coded threshold (democracy >=5 -> use belligerence based on Interventionism). Use Belligerence when sum of all sliders for is above 1.
_MODIFIER_BELLIGERENCE_DOW_ # Additive. Belligerence needed to DoW. Used only when MODIFIER_USE_BELLIGERENCE_FOR_DOW  is greater then 1
_MODIFIER_RELATIONSHIPS_DOW_ # Additive. Relationship needed to DoW – new, enabled from misc.txt #Starting value: -200
_MODIFIER_COUNTERINTELLIGENCE_ # Additive. Used as bonus to current counter-intelligence. The recommended max value from all sliders is 15!
_MODIFIER_INTELLIGENCE_ # Additive. Added to spy levels in distance calculations. Higher it is – distance will have less impact on mission chances. The recommended current values from all sliders are from -5 to +4!
_CAN_ALLY_WHILE_AT_PEACE_
_CAN_ADD_CLAIMS_TO_NEUTRALS_
_CAN_DEMAND_CLAIMS_
_CAN_BREAK_NAP_
_CAN_GUARANTEE_
_MANUAL_OR_ BY_INFLUENCE_MOVES_  # 0 – no slider moves are possible except by events, 1 – manual slider moves are allowed too, 2 – moves by Influence are allowed too

_MODIFIER_UPGRADE_TIME_AND_COST_
was split in two: 
_MODIFIER_UPGRADE_TIME_
_MODIFIER_UPGRADE_COST_

_MODIFIER_PRODUCTION_TIME_ AND_COST_
was split in two:
_MODIFIER_PRODUCTION_TIME_
_MODIFIER_PRODUCTION_COST_

# Minister personalities

All minister modifiers are moved to a moddable file minister_personalities.txt
Added possibility to define new minister personalities with unique effects, including personalities that could be assigned to all government positions.

Moddable effects:
	- Leader skill
	- Research time – per tech or for all
	- Research cost – per tech or for all
	- Resource production bonuses – oil, energy, metal, rare materials, money
	- Production bonuses – foreign IC, national IC, reinforce, upgrade, consumer goods, supplies
	- Units – build time, build cost, attack bonus, defense bonus, morale (org. regain), organization 
	- Brigades - build time, build cost, attack bonus, defense bonus, morale (org. regain), organization 
	- Land unit speed
	- Belligerence – required for DoW, wartime and peacetime 
	- Transport capacity modifier
	- Provincial buildings (IC, coastal and land forts, flak, infrastructure, air and naval bases, radar stations, nuclear reactors and rocket test sites) time and cost
	- Detection – naval, land and convoy
	- Dissent
	- Manpower growth – total and non-national 
	- Supply consumption
	- Spying networks bonus – intelligence (home) and counterintelligence (foreign). Limited up to 5% each!
	- Intelligence reports accuracy – land/air units, navy/convoys and production/research. Values from -10 to 10
	- Diplomatic action chances – trade (used also for trade agreements), alliance (offer, join and bring), non-aggression pact, demand territory, ask for military access, sue for peace (insist on demands, white and beg for peace), assume military control and influence
	- Diplomatic action chances extra modifiers – weak target (Total IC is less then ½), same alignment, opposite alignment, democracies, dictatorships, close government type (difference +/- 2)
	- Diplomatic action cost for each action. The final value can be no less then 0.0
	- Diplomatic action cost extra modifiers – weak target (Total IC is less then ½), same alignment, opposite alignment, democracies, dictatorships, close government type (difference +/- 2), national (actions against us: cost modifier = 1 + Sender’s modifier + Target’s modifier). 
	- Convoy transports and escorts build time and cost (using transport ships and destroyers modifiers) 
	- Intelligence mission cost for each mission – 2 modifiers: for sender and for target (Final cost modifier for a mission = 1 + Sender’s cost modifier + Target’s defense cost modifier). The final value can be no less then 0.0
	- Intelligence funding and maintenance cost modifiers
	- Intelligence mission chances for each mission – 2 modifiers: for sender and for target (Summary chance for a mission = Sender’s modifier + Target’s defense modifier) 
	- stockpile - modifiers on stockpiles limit	# which = industry / supplies (used for oil too) / all (default) # when = war / peace / all (default) # value = x.xxxx

	
# New console command

 “dumpinfo TAG/world” (only in SP games) that saves detailed country information to LogCountry.csv. 
 “unitinfo TAG/world” that saves in savedebug.txt all units by type (deployed and in production) and also oil and supply estimated consumption (by own or allied troops) for a country (TAG) or for all existing countries (world).
	
	
# Notes

# Event actions are now only limited by screen size.

# activate_unit_type and deactivate_unit_type effects are now reversible on doctrine abandon. 

# Event commands modifying units stats now also affect units in production and upgraded units.

# About event AI chances calculation
   - Sum of AI chances of all valid actions could be any positive number (removed fixed sum = 100 prerequisite)
   - Invalid actions are skipped in AI chances calculations
   - Actions without specified AI chances are ignored by the AI if there is at least one valid action with AI chance set
   - If no AI chance is set for valid action, random action is chosen from all valid actions (removed increased chance to pick 1st action)

# About individual command or event actions triggers

Example :

       action = {
          name = "Test"
          trigger = { money = 100 }
          command = { trigger = { ai = yes } type = money value = 500 }
          command = { trigger = { ai = no } type = money value = -90 }
       }

# Here are some performance hints that should be taken into account when events are created

1. Triggers (no matter if these are for events, actions or commands) should be as simple as possible and these that are most likely to fail should be first.
2. If there is at least one action that has no own triggers it should be on top of the actions - that's because action triggers are now considered as continuation of the event trigger and there should be at least one valid action in order for the event to fire. Actions without triggers are considered as always valid (no matter what commands they have in opposite to 1.2/1.3).
3. If all actions has triggers, actions with triggers that are most likely to be true should be on top. This will allow for faster event validation (if main trigger is true and there is at least one valid action the event is good to go).

The following two rules have smaller impact, but as a good practice should be followed too.
4. Commands in actions should be arranged so most likely to be valid commands to be on top of the list.

    command = { type = addcore which = 300 } #Invalid for Germany. Province #300 is Berlin
    command = { type = money value = 10 } # Always valid command - good to have it on top!


5. Command without own triggers should be prioritized in commands list over these using triggers.


# Decisions concept:
	
new modifier in misc.txt (“mod” section): #Enable decisions for players. 0 - Disabled, 1 – Enabled

Basics
1. Decisions are modified events. 
2. They differ from regular event only by the presence of a new section - decision 
3. Decisions are treated as regular events by the AI. 
4. Players have the power to choose when a decision could be applied.
5. Decisions are hidden until all triggers in decision = { } section is true. 
6. Decision are available for selection when all triggers in decision_trigger = { } section in the event are true. If decision_trigger = { } section doesn't exist or is empty, it will use trigger = { } instead.
7. Once selected the decisions fire as regular event via standard event window with all the usual information and actions on it.
8. Decisions are logged in event history as regular events.

New entry in the event : 

decision_desc = "....", optional decision specific text (used on tool-tips instead of event description).
decision_picture = "picture_name.bmp". Optional (there will be a generic picture loaded by default - gfx\event_pics\decisions_empty.bmp), placed on the decision plate
decision_trigger = { }. It is optional and, if not present, trigger = {} will be used instead. When it is true the decisions will be active for selection. 

Limitations
1. Decisions should not use random elements in any triggers so tool-tips to be correct. EDIT No problem to use random trigger in AI only actions or commands
2. For better formatting on tool-tips NOT = { trigger1 ... triggerX } should be used for individual triggers only NOT = { trigger1 } ... NOT = { triggerX } NEW

